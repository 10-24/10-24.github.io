[{"content":"如有卡顿请访问 https://thankful-water-038154a00.2.azurestaticapps.net/\n介绍 你好啊，欢迎来到我的博客，我的博客平时主要以分享技术类的内容为主，主要是一些踩过的坑🕳或是网上冲浪🏄‍♂️的时候遇到的痛点。\n使用 你可以在右侧使用搜索功能 你可以点击右侧的tags或是categories来快速找到你需要的内容 ","date":"2022-11-24T00:00:00Z","permalink":"https://demo.stack.jimmycai.com/p/introduce/","title":"博客介绍 "},{"content":"一键结束进程 起因 我真的绷不住了，Alt+F4 不能够关闭程序，调个任务栏管理器半天不出来，出来了还无响应，我真的服了，只能强制重启。所以我打做个一键杀死进程的程序。\n编写 思路 需要获取当前正在运行的程序 获取当前窗口句柄需要使用到系统函数，通过窗口得到进程pid，所以必须使用win32库 需要能够调用taskkill指令 Python中内置的os.system()代码就能够很好的执行，但是需要提升至管理员身份 加上按键监听 这个部分在我之前的博客超级粘贴也有使用到，就是pynput库 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 import win32gui import win32process import os from pynput.keyboard import Listener,Key import ctypes #判断是否有管理员权限 def is_admin(): try: return ctypes.windll.shell32.IsUserAnAdmin() except: return False #监听 def on_release(key): if key == Key.esc: # 停止监听 return False if key == Key.f2: # 这里是按f2调用kill函数 kill() #杀死进程 def kill(): now_win = win32gui.GetForegroundWindow() now_process = win32process.GetWindowThreadProcessId(now_win)[1] target = r\u0026#39;taskkill /pid {} /F /T\u0026#39;.format(now_process) os.system(target) #开始判断管理员权限 if is_admin() == False: print(\u0026#34;警告:当前非管理员身份运行,可能导致kill失败\u0026#34;) #开始监听 with Listener( on_release=on_release) as listener: listener.join() 我也会把exe文件发布在GitHub上\nhttps://github.com/ohdmire/OnePressKill/releases/\n小趣事 我真tmsb，把文件名称命名为taskkill，结果执行os.system的时候就又调用了一遍该程序，结果我看半天以为是pyinstaller编译出错了，我真的是服了。\n该问题已在v0.2得到修复\n使用教程 只要运行程序按下F2就能杀死当前窗口的程序，按ESC退出程序\n你可能还需要以管理员身份运行该程序\n如果你需要也可以自行更改按键，具体参考官方文档 https://pynput.readthedocs.io/en/latest/keyboard.html\n最后 效果 参考链接 python小工具\u0026ndash;查看窗口程序进程\nPython 获取Windows管理员权限\n","date":"2023-01-07T00:00:00Z","image":"https://demo.stack.jimmycai.com/p/onepresskill/%E5%B0%81%E9%9D%A2_hud6952016226169985b8ba3953ba2dfee_281431_120x120_fill_box_smart1_3.png","permalink":"https://demo.stack.jimmycai.com/p/onepresskill/","title":"一键kill"},{"content":"JavaScript笔记 内容参考来源W3School\n以下内容并不完整，主要是我在我学过Python的基础上，在理解新的语言所需要留意的部分。\n显示方案 JavaScript 能够以不同方式“显示”数据：\n使用 window.alert() 写入警告框 使用 document.write() 写入 HTML 输出 使用 innerHTML 写入 HTML 元素 使用 console.log() 写入浏览器控制台 语法 1 2 3 var x, y;\t// 如何声明变量 x = 7; y = 8;\t// 如何赋值 z = x + y;\t// 如何计算值 块作用域 通过 var 关键词声明的变量没有块作用域。 在块 {} 内声明的变量可以从块之外进行访问。\n可以使用 let 关键词声明拥有块作用域的变量。 在块 {} 内声明的变量无法从块外访问：\n1 2 3 4 5 6 7 8 9 10 { var x = 10; } // 此处可以使用 x { let x = 10; } // 此处不可以使用 x 在第一个例子中，在循环中使用的变量使用 var 重新声明了循环之外的变量。 在第二个例子中，在循环中使用的变量使用 let 并没有重新声明循环外的变量。 如果在循环中用 let 声明了变量 i，那么只有在循环内，变量 i 才是可见的。 1 2 3 4 5 var i = 7; for (var i = 0; i \u0026lt; 10; i++) { // 一些语句 } // 此处，i 为 10 1 2 3 4 5 let i = 7; for (let i = 0; i \u0026lt; 10; i++) { // 一些语句 } // 此处 i 为 7 重新声明变量 允许在程序的任何位置使用 var 重新声明 JavaScript 变量 1 2 3 4 5 6 7 var x = 10; // 现在，x 为 10 var x = 6; // 现在，x 为 6 在不同的作用域或块中，通过 let 重新声明变量是允许的 1 2 3 4 5 6 7 8 let x = 6; // 允许 { let x = 7; // 允许 } { let x = 8; // 允许 } 其余情况不可以重新声明 不是真正的常数 关键字 const 有一定的误导性。 它没有定义常量值。它定义了对值的常量引用。 因此，我们不能更改常量原始值，但我们可以更改常量对象的属性。\n特性 不能改变原始值 可以更改常量对象的属性 1 2 3 4 5 6 7 8 // 您可以创建 const 对象： const car = {type:\u0026#34;porsche\u0026#34;, model:\u0026#34;911\u0026#34;, color:\u0026#34;Black\u0026#34;}; // 您可以更改属性： car.color = \u0026#34;White\u0026#34;; // 您可以添加属性： car.owner = \u0026#34;Bill\u0026#34;; 但是您无法重新为常量对象赋值\n1 2 const car = {type:\u0026#34;porsche\u0026#34;, model:\u0026#34;911\u0026#34;, color:\u0026#34;Black\u0026#34;}; car = {type:\u0026#34;Volvo\u0026#34;, model:\u0026#34;XC60\u0026#34;, color:\u0026#34;White\u0026#34;}; // ERROR 常量数组可以更改 1 2 3 4 5 6 7 8 // 您可以创建常量数组： const cars = [\u0026#34;Audi\u0026#34;, \u0026#34;BMW\u0026#34;, \u0026#34;porsche\u0026#34;]; // 您可以更改元素： cars[0] = \u0026#34;Honda\u0026#34;; // 您可以添加元素： cars.push(\u0026#34;Volvo\u0026#34;); 但是您无法重新为常量数组赋值\n1 2 const cars = [\u0026#34;Audi\u0026#34;, \u0026#34;BMW\u0026#34;, \u0026#34;porsche\u0026#34;]; cars = [\u0026#34;Honda\u0026#34;, \u0026#34;Toyota\u0026#34;, \u0026#34;Volvo\u0026#34;]; // ERROR 运算符 算数 运算符 描述 + 加法 - 减法 * 乘法 / 除法 % 取模（余数） ++ 递加 \u0026ndash; 递减 赋值 运算符 例子 等同于 = x = y x = y += x += y x = x + y -= x -= y x = x - y *= x *= y x = x * y /= x /= y x = x / y %= x %= y x = x % y 比较 运算符 描述 == 等于 === 等值等型 != 不相等 !== 不等值或不等型 \u0026gt; 大于 \u0026lt; 小于 \u0026gt;= 大于或等于 \u0026lt;= 小于或等于 ? 三元运算符 逻辑 运算符 描述 \u0026amp;\u0026amp; 逻辑与 || 逻辑或 ! 逻辑非 类型 运算符 描述 typeof 返回变量的类型。 instanceof 返回 true，如果对象是对象类型的实例。 ？位运算符 运算符 描述 例子 等同于 结果 十进制 \u0026amp; 与 5 \u0026amp; 1 0101 \u0026amp; 0001 0001 1 | 或 5 | 1 0101 | 0001 0101 5 ~ 非 ~ 5 ~0101 1010 10 ^ 异或 5 ^ 1 0101 ^ 0001 0100 4 \u0026laquo; 零填充左位移 5 \u0026laquo; 1 0101 \u0026laquo; 1 1010 10 \u0026raquo; 有符号右位移 5 \u0026raquo; 1 0101 \u0026raquo; 1 0010 2 \u0026raquo;\u0026gt; 零填充右位移 5 \u0026raquo;\u0026gt; 1 0101 \u0026raquo;\u0026gt; 1 0010 2 优先级 20 ( ) 表达式分组 (3 + 4) 19 . 成员 person.name 19 [] 成员 person[\u0026ldquo;name\u0026rdquo;] 19 () 函数调用 myFunction() 19 new 创建 new Date() 17 ++ 后缀递增 i++ 17 \u0026ndash; 后缀递减 i\u0026ndash; 16 ++ 前缀递增 ++i 16 \u0026ndash; 前缀递减 \u0026ndash;i 16 ! 逻辑否 !(x==y) 16 typeof 类型 typeof x 15 ** 求幂 (ES7) 10 ** 2 14 * 乘 10 * 5 14 / 除 10 / 5 14 % 模数除法 10 % 5 13 + 加 10 + 5 13 - 减 10 - 5 12 \u0026laquo; 左位移 x \u0026laquo; 2 12 \u0026raquo; 右位移 x \u0026raquo; 2 12 \u0026raquo;\u0026gt; 右位移（无符号） x \u0026raquo;\u0026gt; 2 11 \u0026lt; 小于 x \u0026lt; y 11 \u0026lt;= 小于或等于 x \u0026lt;= y 11 \u0026gt; 大于 x \u0026gt; y 11 \u0026gt;= 大于或等于 x \u0026gt;= y 11 in 对象中的属性 \u0026ldquo;PI\u0026rdquo; in Math 11 instanceof 对象的实例 instanceof Array 10 == 相等 x == y 10 === 严格相等 x === y 10 != 不相等 x != y 10 !== 严格不相等 x !== y 9 \u0026amp; 按位与 x \u0026amp; y 8 ^ 按位 XOR x ^ y 7 | 按位或 x | y 6 \u0026amp;\u0026amp; 逻辑与 x \u0026amp;\u0026amp; y 5 || 逻辑否 x || y 4 ? : 条件 ? \u0026ldquo;Yes\u0026rdquo; : \u0026ldquo;No\u0026rdquo; 3 = 赋值 x = y 3 += 赋值 x += y 3 -= 赋值 x -= y 3 *= 赋值 x *= y 3 %= 赋值 x %= y 3 \u0026laquo;= 赋值 x \u0026laquo;= y 3 \u0026raquo;= 赋值 x \u0026raquo;= y 3 \u0026raquo;\u0026gt;= 赋值 x \u0026raquo;\u0026gt;= y 3 \u0026amp;= 赋值 x \u0026amp;= y 3 ^= 赋值 x ^= y 3 |= 赋值 x |= y 2 yield 暂停函数 yield x 1 , 逗号 7 , 8 数据类型 1 2 3 4 var length = 7; // 数字 var lastName = \u0026#34;Gates\u0026#34;; // 字符串 var cars = [\u0026#34;Porsche\u0026#34;, \u0026#34;Volvo\u0026#34;, \u0026#34;BMW\u0026#34;]; // 数组 var x = {firstName:\u0026#34;Bill\u0026#34;, lastName:\u0026#34;Gates\u0026#34;}; // 对象 在第一个例子中，JavaScript 把 911 和 7 视作数值，直到遇见 \u0026ldquo;Porsche\u0026rdquo;。 在第二个例子中，由于第一个操作数是字符串，因此所有操作数都被视为字符串。 1 var x = 911 + 7 + \u0026#34;Porsche\u0026#34;; x= 918Porsche\n1 var x = \u0026#34;Porsche\u0026#34; + 911 + 7; x = Porsche9117\nUndefined 与 Null 的区别 Undefined 与 null 的值相等，但类型不相等：\n1 2 3 4 typeof undefined // undefined typeof null // object null === undefined // false null == undefined // true 复杂数据 typeof 运算符可返回以下两种类型之一：\nfunction object typeof 运算符把对象、数组或 null 返回 object。\ntypeof 运算符不会把函数返回 object。\n1 2 3 4 typeof {name:\u0026#39;Bill\u0026#39;, age:62} // 返回 \u0026#34;object\u0026#34; typeof [1,2,3,4] // 返回 \u0026#34;object\u0026#34; (并非 \u0026#34;array\u0026#34;，参见下面的注释) typeof null // 返回 \u0026#34;object\u0026#34; typeof function myFunc(){} // 返回 \u0026#34;function\u0026#34; 函数 1 2 3 function myFunction(p1, p2) { return p1 * p2; // 该函数返回 p1 和 p2 的乘积 } 在 JavaScript 函数中声明的变量，会成为函数的*局部变量\n对象 1 2 3 4 5 6 7 8 var person = { firstName: \u0026#34;Bill\u0026#34;, lastName : \u0026#34;Gates\u0026#34;, id : 678, fullName : function() { return this.firstName + \u0026#34; \u0026#34; + this.lastName; } }; 属性和方法in对象\nthis 关键词 在函数定义中，this 引用该函数的“拥有者”。\n在上面的例子中，this 指的是“拥有” fullName 函数的 person 对象。\n换言之，this.firstName 的意思是 this 对象的 firstName 属性。\n访问对象属性 1 2 3 objectName.propertyName //方法1 objectName[\u0026#34;propertyName\u0026#34;] //方法2 访问对象方法 1 objectName.methodName() 如果您不使用 () 访问 fullName 方法，则将返回函数定义(就是怎么写怎么出)\n1 name = person.fullName; 通过new声明对象 1 2 3 var x = new String(); // 把 x 声明为 String 对象 var y = new Number(); // 把 y 声明为 Number 对象 var z = new Boolean(); //\t把 z 声明为 Boolean 对象 请在JavaScript的编写中避免使用new 关键词\nHTML事件 1 \u0026lt;element event=\u0026#39;一些 JavaScript\u0026#39;\u0026gt; 事件 描述 onchange HTML 元素已被改变 onclick 用户点击了 HTML 元素 onmouseover 用户把鼠标移动到 HTML 元素上 onmouseout 用户把鼠标移开 HTML 元素 onkeydown 用户按下键盘按键 onload 浏览器已经完成页面加载 字符串 转义字符 代码 结果 描述 \\' ' 单引号 \\\u0026quot; \u0026quot; 双引号 \\\\ \\ 反斜杠 代码 结果 \\b 退格键 \\f 换页 \\n 新行 \\r 回车 \\t 水平制表符 \\v 垂直制表符 字符串方法和属性 JavaScript会将字符串视为对象\n字符串位置 length 属性返回字符串的长度 indexOf() 方法返回字符串中指定文本**首次出现的索引（位置） lastIndexOf() 方法返回指定文本在字符串中最后一次出现的索引 如果未找到文本， indexOf() 和 lastIndexOf() 均返回 -1 两种方法都接受作为检索起始位置的第二个参数 search() 方法搜索特定值的字符串，并返回匹配的位置 search() 方法无法设置第二个开始位置参数。 indexOf() 方法无法设置更强大的搜索值（正则表达式）\n提取部分字符串 普通方法 slice(start, end) substring(start, end) substring() 无法接受负的索引\nsubstr(start, length) 安全方法 charAt(position) charAt() 方法返回字符串中指定下标（位置）的字符串\ncharCodeAt(position) charCodeAt() 方法返回字符串中指定索引的字符 unicode 编码\n属性访问法 1 2 var str = \u0026#34;HELLO WORLD\u0026#34;; str[0]; // 返回 H 其他方法 match() 根据正则表达式在字符串中搜索匹配项，并将匹配项作为Array对象返回 1 string.match(regexp) includes()如果字符串包含指定值，includes() 方法返回 true 1 string.includes(searchvalue, start) startsWith()如果字符串以指定值开头，则 startsWith() 方法返回 true，否则返回 false 1 string.startsWith(searchvalue, start) endsWith()如果字符串以指定值结尾，则 endsWith() 方法返回 true，否则返回 false 1 string.endsWith(searchvalue, length) 替换字符串内容 replace() 方法不会改变调用它的字符串。它返回的是新字符串。 默认地，replace() 只替换首个匹配\n需要掌握正则表达式\n转换为大写和小写 通过 toUpperCase() 把字符串转换为大写 通过 toLowerCase() 把字符串转换为小写 其他 concat() 连接两个或多个字符串： trim() 方法删除字符串两端的空白符： 把字符串转换为数组 1 2 3 4 var txt = \u0026#34;a,b,c,d,e\u0026#34;; // 字符串 txt.split(\u0026#34;,\u0026#34;); // 用逗号分隔 txt.split(\u0026#34; \u0026#34;); // 用空格分隔 txt.split(\u0026#34;|\u0026#34;); // 用竖线分隔 如果分隔符是 \u0026ldquo;\u0026quot;，被返回的数组将是间隔单个字符的数组\n字符串模板 模板字面量使用反引号 (``) 而不是引号 (\u0026rdquo;\u0026quot;) 来定义字符串\n插值 模板字面量提供了一种将变量和表达式插入字符串的简单方法\n1 2 3 4 5 6 ${...} let firstName = \u0026#34;Bill\u0026#34;; let lastName = \u0026#34;Gates\u0026#34;; let text = `Welcome ${firstName}, ${lastName}!`; 模板字面量允许字符串中的表达式\n1 2 3 4 let price = 10; let VAT = 0.25; let total = `Total: ${(price * (1 + VAT)).toFixed(2)}`; 数字 JavaScript 数值始终是 64 位的浮点数\n特殊 NaN 属于 JavaScript 保留词，指示某个数不是合法数\nisNaN() 来确定某个值是否是数 Infinity （或 -Infinity）是 JavaScript 在计算数时超出最大可能数范围时返回的值\n十六进制 1 2 3 4 var myNumber = 128; myNumber.toString(16); // 返回 80 myNumber.toString(8); // 返回 200 myNumber.toString(2); // 返回 10000000 数字方法 toString() 以字符串返回数值。 toExponential() 返回字符串值，它包含已被四舍五入并使用指数计数法的数字。 toFixed() 返回字符串值，它包含了指定位数小数的数字 toPrecision() 返回字符串值，它包含了指定长度的数字 valueOf() 以数值返回数值 在 JavaScript 中，数字可以是原始值（typeof = number）或对象（typeof = object）。\n在 JavaScript 内部使用 valueOf() 方法可将 Number 对象转换为原始值。\n没有理由在代码中使用它。\n所有 JavaScript 数据类型都有 valueOf() 和 toString() 方法。\n全局方法 方法 描述 Number() 返回数字，由其参数转换而来。 parseFloat() 解析其参数并返回浮点数。 parseInt() 解析其参数并返回整数。 数值属性 属性 描述 MAX_VALUE 返回 JavaScript 中可能的最大数。 MIN_VALUE 返回 JavaScript 中可能的最小数。 NEGATIVE_INFINITY 表示负的无穷大（溢出返回）。 NaN 表示非数字值（\u0026ldquo;Not-a-Number\u0026rdquo;）。 POSITIVE_INFINITY 表示无穷大（溢出返回）。 1 var x = Number.MAX_VALUE; 数字属性不可用于变量\n1 2 var x = 6; var y = x.MAX_VALUE; // y 成为 undefined 数组 1 2 3 var cars = [\u0026#34;Saab\u0026#34;, \u0026#34;Volvo\u0026#34;, \u0026#34;BMW\u0026#34;]; var array-name = [item1, item2, ...]; 读写数组元素 1 2 3 var name = cars[0]; //访问 cars[0] = \u0026#34;Opel\u0026#34;; //修改 数组元素可以是对象 1 2 3 myArray[0] = Date.now; myArray[1] = myFunction; myArray[2] = myCars; 数组属性和方法 1 2 var x = cars.length; // length 属性返回元素的数量 var y = cars.sort(); // sort() 方法对数组进行排序 length 属性返回数组的长度（数组元素的数目）\n遍历数组的最安全方法是使用 \u0026ldquo;for\u0026rdquo; 循环：\n1 2 3 4 5 6 7 8 var fruits, text, fLen, i; fruits = [\u0026#34;Banana\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#34;Apple\u0026#34;, \u0026#34;Mango\u0026#34;]; fLen = fruits.length; text = \u0026#34;\u0026lt;ul\u0026gt;\u0026#34;; for (i = 0; i \u0026lt; fLen; i++) { text += \u0026#34;\u0026lt;li\u0026gt;\u0026#34; + fruits[i] + \u0026#34;\u0026lt;/li\u0026gt;\u0026#34;; } Array.foreach() 函数 1 2 3 4 5 6 7 8 9 10 var fruits, text; fruits = [\u0026#34;Banana\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#34;Apple\u0026#34;, \u0026#34;Mango\u0026#34;]; text = \u0026#34;\u0026lt;ul\u0026gt;\u0026#34;; fruits.forEach(myFunction); //调用数组的每个元素，并将元素传递给回调函数 text += \u0026#34;\u0026lt;/ul\u0026gt;\u0026#34;; function myFunction(value) { text += \u0026#34;\u0026lt;li\u0026gt;\u0026#34; + value + \u0026#34;\u0026lt;/li\u0026gt;\u0026#34;; } 添加数组元素 push() 方法\n1 2 var fruits = [\u0026#34;Banana\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#34;Apple\u0026#34;, \u0026#34;Mango\u0026#34;]; fruits.push(\u0026#34;Lemon\u0026#34;); // 向 fruits 添加一个新元素 (Lemon) 或者指定\n1 2 var fruits = [\u0026#34;Banana\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#34;Apple\u0026#34;, \u0026#34;Mango\u0026#34;]; fruits[6] = \u0026#34;Lemon\u0026#34;; // 向 fruits 添加一个新元素 (Lemon) 添加最高索引的元素可在数组中创建\u0026quot;未定义\u0026quot;\n关联数组 数组只能使用数字索引\n以下内容属于命名索引\nJavaScript 会把数组重定义为标准对象，所有数组的方法和属性将产生非正确结果。\n1 2 3 4 5 6 var person = []; person[\u0026#34;firstName\u0026#34;] = \u0026#34;Bill\u0026#34;; person[\u0026#34;lastName\u0026#34;] = \u0026#34;Gates\u0026#34;; person[\u0026#34;age\u0026#34;] = 62; var x = person.length; // person.length 将返回 0 var y = person[0]; // person[0] 将返回 undefined 识别数组 typeof 返回 \u0026ldquo;object\u0026rdquo; 1 2 3 var fruits = [\u0026#34;Banana\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#34;Apple\u0026#34;, \u0026#34;Mango\u0026#34;]; typeof fruits; // 返回 object Array.isArray() 1 Array.isArray(fruits); // 返回 true 其他\u0026hellip;\u0026hellip;. 把数组转换为字符串 toString() 把数组转换为数组值（逗号分隔）的字符串 join() 方法也可将可以规定分隔符 删除元素和添加新元素 转移 pop() 方法从数组中删除最后一个元素 shift() 方法会删除首个数组元素，并把所有其他元素“位移”到更低的索引 添加 push() 方法（在数组结尾处）向数组添加一个新的元素 unshift() 方法（在开头）向数组添加新元素，并把所有其他元素“位移”到更高的索引 push()和unshift()方法返回新数组的长度\n1 2 var fruits = [\u0026#34;Banana\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#34;Apple\u0026#34;, \u0026#34;Mango\u0026#34;]; fruits.unshift(\u0026#34;Lemon\u0026#34;); // 返回 5 删除 使用 delete 会在数组留下未定义的空洞\n1 2 var fruits = [\u0026#34;Banana\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#34;Apple\u0026#34;, \u0026#34;Mango\u0026#34;]; delete fruits[0]; // 把 fruits 中的首个元素改为 undefined 拼接数组 splice() 方法可用于向数组添加新项\n1 2 var fruits = [\u0026#34;Banana\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#34;Apple\u0026#34;, \u0026#34;Mango\u0026#34;]; fruits.splice(2, 2, \u0026#34;Lemon\u0026#34;, \u0026#34;Kiwi\u0026#34;); 第一个参数（2）定义了应添加新元素的位置（拼接）。\n第二个参数（2）定义应删除多少元素。\n其余参数（“Lemon”，“Kiwi”）定义要添加的新元素。\nsplice() 方法返回一个包含已删除项的数组：\nsplice() 在数组中**不留“空洞”**的情况下移除元素\n合并（连接）数组 concat() 方法通过合并（连接）现有数组来创建一个新数组\n1 2 3 4 var arr1 = [\u0026#34;Cecilie\u0026#34;, \u0026#34;Lone\u0026#34;]; var arr2 = [\u0026#34;Emil\u0026#34;, \u0026#34;Tobias\u0026#34;, \u0026#34;Linus\u0026#34;]; var arr3 = [\u0026#34;Robin\u0026#34;, \u0026#34;Morgan\u0026#34;]; var myChildren = arr1.concat(arr2, arr3); // 将arr1、arr2 与 arr3 连接在一起 裁剪数组 slice() 方法用数组的某个片段切出新数组\nslice() 可接受两个参数，比如 (1, 3)。\n该方法会从开始参数选取元素，直到结束参数（不包括）为止。\n","date":"2022-12-14T00:00:00Z","image":"https://demo.stack.jimmycai.com/p/javascriptnote/%E5%B0%81%E9%9D%A2_hu6a9e9f830e372fdd12adb83365e5115c_54079_120x120_fill_box_smart1_3.png","permalink":"https://demo.stack.jimmycai.com/p/javascriptnote/","title":"JavaScript笔记"},{"content":"超级粘贴 起因 最近发现一些平台是不能直接粘贴内容的（具体我就不说是哪个平台了😅），所以我编写了一段超级粘贴的程序\n编写 思路 毕竟粘贴这个行为是不合法的，那么我们能不能通过模拟键盘输入的方式来进行“粘贴”呢？这样思路就十分清晰了\n读取剪切板内容 将内容通过模拟键盘进行粘贴 我只会Python所以我就用Python来写:)\n编写过程 首先采用的是pyperclip进行剪切板读取，这一步没有什么问题。 然后我采用pyautogui模拟输入，然后重点是它不能输入中文 于是我又去网上找了找能输入中文的方案，最终找到了一个很好用的库pynput 到这就终于能输入中文了。 最后再加上按键监听就完成了 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import pyperclip from pynput.keyboard import Controller,Listener,Key import time def paste(): time.sleep(0.2) #按下后间隔0.2s i=pyperclip.paste() keyboard = Controller() keyboard.type(i) print(\u0026#34;粘贴成功\u0026#34;+\u0026#34;\\n\u0026#34;+i+\u0026#34;\\n\u0026#34;) def on_release(key): if key == Key.esc: # 停止监听 return False if key == Key.f2: # 这里是按f2调用粘贴函数 paste() with Listener( on_release=on_release) as listener: listener.join() 我也会把exe文件发布在GitHub上\nhttps://github.com/ohdmire/SuperPaste/releases\n使用教程 只要运行程序按下F2就能粘贴，按ESC退出程序\n你可能还需要将输入法切换为英文\n如果你需要也可以自行更改按键，具体参考官方文档 https://pynput.readthedocs.io/en/latest/keyboard.html\n最后 效果 参考链接 pynput文档\n","date":"2022-12-12T00:00:00Z","image":"https://demo.stack.jimmycai.com/p/superpaste/%E5%B0%81%E9%9D%A2_hud6952016226169985b8ba3953ba2dfee_281431_120x120_fill_box_smart1_3.png","permalink":"https://demo.stack.jimmycai.com/p/superpaste/","title":"超级粘贴"},{"content":"pyTranscriber 引言 你有没有过需要视频生成字幕的需求但是网上的转换都是收费的？今天我将介绍一个神器pyTranscriber能够免费生成视频字幕\n安装步骤 注意，你可能需要一定的Python cmd git知识\n首先你需要下载项目(推荐使用git clone) https://github.com/raryelcostasouza/pyTranscriber 你需要安装Python(勾选上 add to path) https://www.python.org/ 请打开cmd，cd到项目的目录中 输入pip install -r requirement.txt安装依赖 输入python main.py打开项目 你也可以使用虚拟Python环境安装软件，如poetry\n使用教程 生成字幕文件 首先打开软件是英文页面，点击标题栏上language按钮选择简体中文 再点击旁边的setting选项，设置好一个能连接上Google的代理(点击test可以测试连接可用性) 之后选择文件和视频的语言(原视频是什么语言就选什么语言) 点击生成字幕之后耐心等待 最后你会得到srt和txt文件 到这里就已经结束了，请享用你的字幕吧\n翻译 翻译网站 如果你还想翻译字幕，推荐你使用字幕翻译网站 https://translatesubtitles.com/\n上传字幕文件，然后选择翻译然后下载下来 当然你也可以使用有道翻译等国内翻译软件 （有道翻译有大学生免费翻译文档）\n有道翻译 将srt以文本打开，复制一份到word文档\n将word文档上传翻译，再复制内容回srt保存\n结果 (这是选择两份字幕的最终效果)\n","date":"2022-12-01T00:00:00Z","image":"https://demo.stack.jimmycai.com/p/pytranscriber/%E4%B8%BB%E9%A1%B5%E9%9D%A2_hu0e7064b61b51e2972b73936a53bd37f9_1627172_120x120_fill_box_smart1_3.png","permalink":"https://demo.stack.jimmycai.com/p/pytranscriber/","title":"视频字幕神器pyTranscriber"},{"content":"笔记 这些笔记是我阅读知乎上觉得重要的内容摘抄下来的\n世界是事实的总和，而非物的总和 我们观察的不可能是超越时间的、不变的“物” 实无穷与潜无穷 排中律 世界是无限的 当用“非A”代替“B”时，其逻辑依然是“A或非A”为真的条件是“A为真”或“非A”为真，而不能说“A或非A”这个命题恒为真。 世界是有限的 保证了A和非A构成一个整体 “真的意义” 当命题表达了实际情况时，命题就是“真”的；否则命题就是表达了非实际情况，也就是“假”的。维特根斯坦用这个命题将世界的“真”锁定在过去和当下中。 两类逻辑 “逻辑必然的数学推理”和“逻辑不必然的力学推理” 维特根斯坦通过这个命题（1.13逻辑空间中的事实是世界）区分了“数学的逻辑”和“力学的逻辑” 数学的每一个定理和推论都是公理的同义反复或者是公理的矛盾命题，这类命题要不是必然的，要不是不可能的，它们的“真、假”在逻辑上是必然的，但是也没有告诉人们新的知识。而力学的逻辑，或者说物理命题的“真假”是由它们是否与事实一致进行判断的。 逻辑空间中的“事实”是物理命题，而逻辑空间中的“非事实”则是纯形式化的逻辑命题。 世界是可还原的 使用还原论去认识世界 一个基本组成成分和另一个相互独立，互不影响 与还原论相对的是整体论或系统论，就是把复杂系统看着是一个整体 世界之内与世界之外 世界是所有基本事态的存在 “物的可能状态”只有在实际发生后，才进入世界之内。而“物的可能状态”没有实际发生，那么就是在世界之外。 参考链接 维特根斯坦《逻辑哲学论》解读\n","date":"2022-11-24T00:00:00Z","image":"https://demo.stack.jimmycai.com/p/wittgenstein/note_hub3861a2fc8a714cba5025c698d818fe3_288583_120x120_fill_q75_box_smart1.jpg","permalink":"https://demo.stack.jimmycai.com/p/wittgenstein/","title":"维特根斯坦"},{"content":"网站涉及相关 网站设计 首先我使用了Hugo这个网站框架并且配上了stack主题\n网站搭建 将网站搭建在GitHub Pages上\n还使用了Azure的静态web解析，相当于有两个域名了\n网站编辑 我使用Obsidian进行博客网站的编辑，他支持Markdown语言，并且拥有模板。\n本来是向用Visual Studio Code 进行编辑的，这样还可以做到编译和发布all in one，但是考虑到模板和文件内容整理问题，我还是使用了Obsidian\n同时我编辑的内容也通过OneDrive同步到云端，这样也不用担心数据丢失的问题\n网站更新 使用Hugo编译好网站之后用git将写好的内容push到远程仓库里，这样就能够实现更新博客内容\n总结 这次建设网站没有花我一分钱，域名啥的我也没有购买。\n我觉得这是非常适合我这穷学生的建设网站的方式。如果有兴趣的话我也可以出一篇详细的建设教程。\n","date":"2022-11-24T00:00:00Z","permalink":"https://demo.stack.jimmycai.com/p/website-software/","title":"我网站使用的一些东西"}]